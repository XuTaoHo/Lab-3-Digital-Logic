
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Lab3(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

reg reset;
wire system_timing;
reg [1:0] mem_input;
wire [1:0] current_state;
reg [3:0] auto_counter;

wire [9:0] autoled, manualled;
wire [7:0] autohex, manualhex;

//=======================================================
//  Structural coding
//=======================================================

initial begin
	reset = 1'b1;
end

always @ (posedge system_timing or negedge reset) begin
	if (reset == 0) begin
		auto_counter = 0;
		mem_input = 0;
	end

	else if (auto_counter == 5) begin
		if (mem_input == 2'b11) begin
			mem_input = 0;
		end

		else begin
			mem_input = mem_input + 1;
		end
		auto_counter = 0;
	end

	else begin
		auto_counter = auto_counter + 1;
	end
end

always @ (negedge KEY[0]) begin
	reset = ~reset;
end

clock_divider system_control (
	.clock(ADC_CLK_10),
	.reset_n(reset),
	.out_clock(system_timing)
);


next_state state_control ( // when submitting final design, remove this module. This module 
	.clock(system_timing), // controls what the next output is based on physical inputs, which
	.reset(reset),		   // will fight for control with the memory module for control of the current state
	.SW(SW),
	.KEY(KEY),
	.current_state(current_state)
);

wire current_state_auto;

mem auto_state(
	.address(mem_input),
	.clock(system_timing),
	.q(current_state_auto)
);

output_control control_output (
	.current_state(current_state),
	.clock(system_timing),
	.reset(reset),
	.LEDR(manualled),
	.HEX0(manualhex)
);

output_control control_output_automatic (
	.current_state(mem_input),
	.clock(system_timing),
	.reset(reset),
	.LEDR(autoled),
	.HEX0(autohex)
);

assign LEDR[9:0] = SW[9] ? autoled[9:0]: manualled[9:0];
assign HEX0[7:0] = SW[9] ? autohex[7:0]: manualhex[7:0];

assign HEX5 = 8'b1111_1111;
assign HEX4 = 8'b1111_1111;
assign HEX3 = 8'b1111_1111;
assign HEX2 = 8'b1111_1111;
assign HEX1 = 8'b1111_1111;

endmodule
